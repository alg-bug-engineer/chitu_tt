# SPDX-FileCopyrightText: 2025 Qingcheng.AI
#
# SPDX-License-Identifier: Apache-2.0

"""
Data-Parallel Token Sender
Sends tokens generated by a DP group back to the Token Router
"""

import logging
import time
from typing import Any, Optional
import threading
import queue
import zmq, os
from chitu.task import Task

logger = logging.getLogger(__name__)


class DPTokenSender:
    """Token sender in DP mode, responsible for sending tokens to the Router"""

    def __init__(
        self, router_address: str = "tcp://localhost:29700", dp_group_id: int = 0
    ):
        self.router_address = router_address
        self.dp_group_id = dp_group_id
        self.socket = None
        self.context = None
        self._send_queue = None
        self._sender_thread = None
        self._started = False
        self._start_lock = threading.Lock()

        self.instance_id = id(self)
        logger.info(
            f"DPTokenSender created: group={dp_group_id}, instance_id={self.instance_id}, router={router_address}"
        )

        self.request_token_cache: dict[str, list[int]] = {}

    async def start(self):
        """Start token sender (initialize synchronous ZMQ socket and sender thread)"""
        with self._start_lock:
            if self._started:
                return
            self._init_socket()
            self._start_sender_thread()
            self._started = True
            logger.info(f"DPTokenSender started for group {self.dp_group_id}")

    def _init_socket(self):
        """Initialize synchronous ZMQ socket"""
        if self.socket is not None:
            return

        self.context = zmq.Context.instance()
        self.socket = self.context.socket(zmq.PUSH)
        self.socket.setsockopt(zmq.LINGER, 0)
        # 提升缓冲与高水位，减少回压导致的阻塞
        sndhwm = int(os.getenv("DP_SND_HWM", "200000"))
        sndbuf = int(os.getenv("DP_SNDBUF", "4194304"))  # 4MB
        conflate = int(os.getenv("DP_CONFLATE", "0"))
        tcp_keepalive = int(os.getenv("DP_TCP_KEEPALIVE", "1"))
        self.socket.setsockopt(zmq.SNDHWM, sndhwm)
        self.socket.setsockopt(zmq.SNDBUF, sndbuf)
        self.socket.setsockopt(zmq.CONFLATE, conflate)
        self.socket.setsockopt(zmq.TCP_KEEPALIVE, tcp_keepalive)
        from chitu.global_vars import get_global_args

        router_host = get_global_args().dp_config.router.host
        router_token_base_port = get_global_args().dp_config.router.token_port
        router_addr = self.router_address
        if router_host and router_token_base_port is not None:
            port = int(router_token_base_port) + int(self.dp_group_id)
            router_addr = f"tcp://{router_host}:{port}"
            logger.info(f"port: {port}, router_addr: {router_addr}")
        self.socket.connect(router_addr)
        logger.info(
            f"[DPTokenSender] group={self.dp_group_id} connect={router_addr} host_cfg={router_host} base_cfg={router_token_base_port}"
        )
        if self._send_queue is None:
            self._send_queue = queue.Queue(maxsize=10000)

    def _start_sender_thread(self):
        # 避免重复启动多个发送线程（ZeroMQ socket 非线程安全）
        if self._sender_thread is not None and self._sender_thread.is_alive():
            return

        def _loop():
            while True:
                try:
                    data = self._send_queue.get()
                    if data is None:
                        break
                    # 优先非阻塞发送，失败时短暂退避重试，再退化阻塞
                    try:
                        self.socket.send(data, flags=zmq.DONTWAIT)
                    except Exception:
                        time.sleep(0.0005)
                        try:
                            self.socket.send(data, flags=zmq.DONTWAIT)
                        except Exception:
                            self.socket.send(data, flags=0)
                except Exception as e:
                    logger.error(f"DPTokenSender sender thread error: {e}")
                    time.sleep(0.01)

        self._sender_thread = threading.Thread(target=_loop, daemon=True)
        self._sender_thread.start()

    def send_token(
        self,
        request_id: str,
        token: int,
        top_logprobs: Optional[list[float]] = None,
        top_token_idx: Optional[list[int]] = None,
        task=None,  # Add task parameter to get prompt_len
    ):
        """Send a single token to the Router"""
        try:
            from chitu.backend import Backend

            # Check if this is the first token and get prompt_len
            is_first_token = request_id not in getattr(self, "_first_token_sent", set())
            if not hasattr(self, "_first_token_sent"):
                self._first_token_sent = set()

            if is_first_token:
                self._first_token_sent.add(request_id)

            logger.debug(
                f"DP Token Sender: [request {request_id}] prepare to send token {token}, is_first_token={is_first_token}"
            )

            # Decode token to text
            text = ""
            if Backend.tokenizer is not None:
                try:
                    text = Backend.tokenizer.decode([token])
                    logger.debug(
                        f"DP Token Sender: [request {request_id}] decode token {token} -> '{text}'"
                    )
                except Exception as decode_error:
                    logger.error(
                        f"DP Token Sender: [request {request_id}] token decode failed: {decode_error}"
                    )
                    text = f"[DECODE_ERROR_{token}]"
            else:
                logger.warning(
                    f"DP Token Sender: [request {request_id}] tokenizer not available, cannot decode token {token}"
                )
                text = f"[TOKEN_{token}]"

            # Decode top_tokens (if present)
            top_tokens_text = None
            if top_token_idx is not None and Backend.tokenizer is not None:
                try:
                    top_tokens_text = [
                        Backend.tokenizer.decode([idx]) for idx in top_token_idx
                    ]
                    logger.info(
                        f"DP Token Sender: [request {request_id}] decode top_tokens {top_token_idx} -> {top_tokens_text}"
                    )
                except Exception as decode_error:
                    logger.error(
                        f"DP Token Sender: [request {request_id}] top_tokens decode failed: {decode_error}"
                    )
                    top_tokens_text = [f"[DECODE_ERROR_{idx}]" for idx in top_token_idx]

            data = {
                "type": "token",
                "request_id": request_id,
                "text": text,
                "original_token_id": token,
                "scheduler_id": self.dp_group_id,
                "timestamp": time.time(),
            }

            # If first token and task provided, include prompt_len info
            if (
                is_first_token
                and task is not None
                and hasattr(task, "req")
                and hasattr(task.req, "prompt_len")
            ):
                data["prompt_len"] = task.req.prompt_len
                logger.info(
                    f"DP Token Sender: [request {request_id}] first token, prompt_len={task.req.prompt_len}, token={token}"
                )

            if top_logprobs is not None:
                data["top_logprobs"] = top_logprobs
            if top_tokens_text is not None:
                data["top_tokens_text"] = top_tokens_text

            self._send_data(data)

        except Exception as e:
            logger.error(
                f"DP Token Sender: [request {request_id}] send token failed: {e}"
            )
            import traceback

            logger.error(
                f"DP Token Sender: [request {request_id}] send token failed details: {traceback.format_exc()}"
            )

    def send_finish(self, request_id: str, finish_reason: str = "stop"):
        """Send request finish signal"""
        try:
            data = {
                "type": "finish",
                "request_id": request_id,
                "finish_reason": finish_reason,
                "scheduler_id": self.dp_group_id,
                "timestamp": time.time(),
            }

            self._send_data(data)

            if request_id in self.request_token_cache:
                del self.request_token_cache[request_id]

            last_decoded_len_key = f"_last_decoded_len_{request_id}"
            if hasattr(self, last_decoded_len_key):
                delattr(self, last_decoded_len_key)

        except Exception as e:
            logger.error(
                f"DP Token Sender: [request {request_id}] send finish signal failed: {e}"
            )

    def send_error(self, request_id: str, error_message: str):
        """Send error signal"""
        try:
            data = {
                "type": "error",
                "request_id": request_id,
                "error": error_message,
                "scheduler_id": self.dp_group_id,
                "timestamp": time.time(),
            }

            self._send_data(data)

            if request_id in self.request_token_cache:
                del self.request_token_cache[request_id]

            last_decoded_len_key = f"_last_decoded_len_{request_id}"
            if hasattr(self, last_decoded_len_key):
                delattr(self, last_decoded_len_key)

        except Exception as e:
            logger.error(
                f"DP Token Sender: [request {request_id}] send error signal failed: {e}"
            )

    def _send_data(self, data: dict[str, Any]):
        """Send data to Router (enqueue; background thread will send)"""
        try:
            import msgpack

            packed_data = msgpack.packb(data)
            self._send_queue.put(packed_data, block=False)
        except queue.Full:
            logger.warning("DP Token Sender: send queue is full, dropping token")
        except Exception as e:
            logger.error(f"DP Token Sender: data send failed: {e}")

    def close(self):
        """Close connection"""
        try:
            if hasattr(self, "_send_queue"):
                self._send_queue.put(None)
            if hasattr(self, "_sender_thread"):
                self._sender_thread.join(timeout=1)
        except Exception:
            pass
        if self.socket:
            try:
                self.socket.close(0)
            except Exception:
                pass
        # do not term the shared context
        self.request_token_cache.clear()
        self._started = False
        logger.info(f"DPTokenSender closed for group {self.dp_group_id}")


class DPTaskWrapper:
    """DP Task wrapper with integrated Token Sender capability"""

    def __init__(self, original_task: Task, token_sender: DPTokenSender):
        self.original_task = original_task
        self.token_sender = token_sender
        self._original_update_response_sync = original_task.update_response_no_sync

        original_task.update_response_no_sync = self._dp_update_response_sync

    def _dp_update_response_sync(self, token: int):
        """Override update_response_sync to also send token to Router (sync enqueue, keep order)"""
        self._original_update_response_sync(token)
        try:
            # Enqueue in order to keep relative order with finish
            self._send_token_to_router(token)
        except Exception as e:
            logger.error(f"[DPTaskWrapper] Failed to send token: {e}")

    def _send_token_to_router(self, token: int):
        """Synchronously enqueue current token to Router sending queue (lightweight, keep order)"""
        try:
            request_id = self.original_task.req.request_id
            top_logprobs = None
            top_token_idx = None

            self.token_sender.send_token(
                request_id=request_id,
                token=token,
                top_logprobs=top_logprobs,
                top_token_idx=top_token_idx,
                task=self.original_task,  # Pass task for prompt_len info
            )

            logger.debug(
                f"[DPTaskWrapper] Token sent successfully: {request_id} -> {token}"
            )

            if self.original_task.need_remove():
                self.token_sender.send_finish(
                    request_id=request_id,
                    finish_reason=self.original_task.req.finish_reason or "stop",
                )
                logger.debug(f"[DPTaskWrapper] Finish signal sent: {request_id}")

        except Exception as e:
            logger.error(f"[DPTaskWrapper] Error during token sending: {e}")
            import traceback

            logger.error(f"[DPTaskWrapper] Error details: {traceback.format_exc()}")

    def __getattr__(self, name):
        """Delegate other attributes to the original task"""
        return getattr(self.original_task, name)


class DPTokenManager:
    """DP Token Manager: manages token sending for the whole DP group"""

    def __init__(self, dp_group_id: int, router_address: str = "tcp://localhost:29700"):
        self.dp_group_id = dp_group_id
        self.router_address = router_address
        self.token_sender = DPTokenSender(router_address, dp_group_id)
        self.wrapped_tasks: dict[str, DPTaskWrapper] = {}

        self.instance_id = id(self)
        logger.info(
            f"DPTokenManager created: group={dp_group_id}, instance_id={self.instance_id}, router={router_address}"
        )

    async def start(self):
        """Start Token Manager"""
        await self.token_sender.start()
        logger.debug(f"DP Token Manager started for group {self.dp_group_id}")

    def wrap_task(self, task: Task) -> DPTaskWrapper:
        """Wrap Task to enable token sending"""
        if task.req.request_id in self.wrapped_tasks:
            return self.wrapped_tasks[task.req.request_id]

        wrapped = DPTaskWrapper(task, self.token_sender)
        self.wrapped_tasks[task.req.request_id] = wrapped

        logger.debug(f"Wrapped task {task.req.request_id} for DP token sending")
        return wrapped

    def unwrap_task(self, request_id: str):
        """Unwrap Task"""
        if request_id in self.wrapped_tasks:
            del self.wrapped_tasks[request_id]

    async def send_error_for_request(self, request_id: str, error_message: str):
        """Send error for a specific request"""
        await self.token_sender.send_error(request_id, error_message)

    def close(self):
        """Close manager"""
        self.token_sender.close()


# Global instances (one per DP group)
_dp_token_managers: dict[int, DPTokenManager] = {}


def get_dp_token_manager(
    dp_group_id: int, router_address: str = "tcp://localhost:29700"
) -> DPTokenManager:
    """Get DP Token Manager instance"""
    global _dp_token_managers

    if dp_group_id not in _dp_token_managers:
        _dp_token_managers[dp_group_id] = DPTokenManager(dp_group_id, router_address)

    return _dp_token_managers[dp_group_id]


async def start_dp_token_manager(
    dp_group_id: int, router_address: str = "tcp://localhost:29700"
):
    """Start Token Manager for the specified DP group"""
    manager = get_dp_token_manager(dp_group_id, router_address)
    await manager.start()
    return manager
